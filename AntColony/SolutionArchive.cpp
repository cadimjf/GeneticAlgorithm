

#include "SolutionArchive.h"

/***
Before the start of the algorithm, the archive is initialized with k random solutions.
At each algorithm iteration, first, a set of m solutions is generated by the ants and
added to those in T. From this set of k + m solutions, the m worst ones are removed.
The remaining k solutions are sorted according to their quality (i.e., the value of the
objective function) and stored in the new T
*/

SolutionArchive::SolutionArchive(int id, int paramNum, 
  double(*fit_function)(vector<double>)):ParameterSet(id, paramNum, fit_function){

  this->probability = 0.;
  this->weight =0.;


}
/**
 * Compute the fitness of this individual
 * */
void SolutionArchive::getFitness(){
  //computes the fitness (defined by user)
  this->evaluate();
  this->updateParameters();  
}

/***
In the remainder of this paper
we use a Gaussian function g(μ, ¾) = g(1, qk), which was also used in our previous
work [Socha and Dorigo, 2008]:
where, q is a parameter of the algorithm and k is the size of the archive. The mean of
the Gaussian function is set to 1, so that the best solution has the highest weight.
*/
double SolutionArchieve::computeWeight(int k, int j, double q ){
  if(j>=k){
    throw MyException("Parameter j has be lower than k ", __FILE__, __LINE__);
  }
  this->weight = (1.0/(q*k*sqrt(2.0*std::numbers::pi))*exp(-pow(j-1, w)/(2.*q*q*k*k)));
  return weight;
}

/***
 * An ant chooses probabilistically one of the solutions in the
archive. The probability of choosing solution j is given by:
 * */
double SolutionArchieve::getProbability(double sumWeights){
  this->probability = this->weight / sumWeights; 
  return probability;
}