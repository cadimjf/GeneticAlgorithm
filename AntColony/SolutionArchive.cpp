

#include "SolutionArchive.h"

/***
 * Before the start of the algorithm, the archive is initialized with k random solutions.
 * At each algorithm iteration, first, a set of m solutions is generated by the ants and
 * added to those in T. From this set of k + m solutions, the m worst ones are removed.
 * The remaining k solutions are sorted according to their quality (i.e., the value of the
 * objective function) and stored in the new T
 *
 * @param id
 * @param paramNum
 * @param fit_function
 */
SolutionArchive::SolutionArchive(int id, int paramNum, 
  double(*fit_function)(vector<double>)):ParameterSet(id, paramNum, fit_function)
{

    this->probability = 0.;
    this->weight =0.;
}
/**
 * Compute the fitness of this individual
 * */
void SolutionArchive::getFitness(){
  //computes the fitness (defined by user)
  this->evaluate();
  this->updateParameters();  
}

/***
In the remainder of this paper
we use a Gaussian function g(μ, ¾) = g(1, qk), which was also used in our previous
work [Socha and Dorigo, 2008]:
where, q is a parameter of the algorithm and k is the size of the archive. The mean of
the Gaussian function is set to 1, so that the best solution has the highest weight.
 *
 * @param k
 * @param j
 * @param q
 * @return
 */
double SolutionArchive::computeWeight(int k, int j, double q ){
    if(j>=k){
        throw MyException("Parameter j has be lower than k ", __FILE__, __LINE__);
    }
    this->weight = (1.0/(q*k*sqrt(2.0*M_PI))*exp(-powf(j, 2.)/(2.*q*q*k*k)));
    return this->weight;
}

/***
 * An ant chooses probabilistically one of the solutions in the
archive. The probability of choosing solution j is given by:
 *
  *
  * @param sumWeights
  * @return
  */
double SolutionArchive::computeProbability(double sumWeights){
    this->probability = this->weight / sumWeights;
    return this->probability;
}
double SolutionArchive::getProbability(){
    return probability;
}

double SolutionArchive::getWeight(){
    return weight;
}